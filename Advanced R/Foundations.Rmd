---
title: 'Advanced R: Foundations'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

https://adv-r.hadley.nz/foundations-intro.html

# Vectors
## Atomic Vectors
4 primary types:
* logical
* integer
* double
* character

Integer and double vectors are collectively known as numeric vectors

### scalars
Each of the four primary vector types has a special syntax to create an individual value (scalar).

* logical: TRUE or FALSE
* doubles: decimal, scientific or hexadecimal numbers
  * also have three special values:
    * Inf
    * -Inf
    * NaN (not a number)
* integers: integers must be followed by L. They can be written in scientific and hexadecimal forms too
* strings/characters: surrounded by "". Special characters are escaped with "\"

### making longer vectors with `c()`
`c()` short for combine. If the inputs of `c()` are more atomic vectors, it flattens them.

You can determine the type of a vector with `typeof()` and length with `length()`.

### missing values
Represented with NA. Test for the presence of missingness with `is.na()`

### testing and coercion
`is.*()` functions to test if a vector is of a given type.

For atomic vectors, type is a property of the entire vector. All elements must be the same type. When you combine different types they are coerced in this order: characters -> double -> integer -> logical.

When logical vectors are coerced to numeric, TRUE = 1 and FALSE = 0.

Mathematical functions coerce automatically but you can deliberately coerce with `as.*()` functions. This can lead to the introduction of NAs where coercion is failed.


## Attributes
### getting and setting
Attributes can be thought of as name-value pairs that attach metadata to an object.
* `attr()`: sets and gets individual attributes
* `attributes()`: gets attributes en masse
* `structure()`: set en masse

Most attributes are lost through most operations. Only names and dimensions are routinely preserved. Names are character vectors giving each element a name and dim is an integer vector used to turn vectors into matrices or arrays.

### names
Ways to name a vector:
* when creating it: `x <- c(a = 1, b = 2, c = 3)`
* `names()`: `x <- 1:3`
              `names(x) <- c("a", "b", "c")`
* `setnames()`: `x <- setNames(1:3, c("a", "b", "c"))`

Remove names from a vector with `unname()` or `names(x) <- NULL`

### dimensions
Adding a dim attribute allows a vector to behave like a 2D matrix or a multi-dimensional array. 

Ways to create matrices and arrays:
* `matrix()`
* `array()`
* `dim()`

Many of the functions for working with vectors have equivalents for matrices and arrays. E.g. names() for vectors and rownames() and colnames() for matrices and dimnames() for arrays.


## S3 Atomic Vectors
The class attribute: having one turns an object into an S3 object. S3 objects behave differently when passed to a generic function. Every S3 object is built on top of a base type and often stores additional information in other attributes.

Four common S3 vectors:
* categorical vectors: where values comes from a fixed set of levels recorded in factor vectors
* dates: recorded in date vectors
* date-times: POSIXct vectors
* durations: difftime vectors

### factors
Characteristics:
* a vector that can only take a predefined value
* used to store categorical vectors
* built on top of an integer vector
* has two attributes:
  * class: "factor", makes it behave differently from regular integer vectors
  * levels: defines the set of allowed values

Factors are useful when you know the set of possible values but they're not all present in the dataset. Some base R functions automatically convert character vectors to categorical vectors/factors. But, they do this without knowing the full set of values the data can assume. It is better to manually set character vectors to factors with your knowledge of all the theoretical values that can be taken. You can suppress the conversion with `stringsAsFactors = FALSE`.

Factors are built on top of integers so be careful when treating them like strings. Some functions recognise this and automatically coerce factors to strings, others don't. It is best to explicitly convert factors to character vectors before manipulating them like strings.

### dates
Characteristics:
* built on top of double vectors
* only one attribute
  * class: "Date"

The value of the double can viewed by removing the class with `unclass()` and it represent the number of days since 1970-01-01. 

### date-times
Characteristics:
* built on top of double vectors (the value of the double represent the number of seconds since 1970-01-01)
* attributes:
  * class: "POSIXct" or "POSIXlt"
  * tzone: time zone which affects how the time is printed

### durations
Characteristics:
* represent the amount of time between pairs of dates or date-times
* built on top of doubles
* attributes:
  * class: "difftime:
  * units: unit of time


## Lists
* each element of a list can be of any type, not just a vector
* elements of a list are references (not copies of components) so the size of a list is much smaller than might be expected
* recursive - can contain other lists
  * `c()` will combine several lists into one
  * this property makes them fundamentally different from atomic vectors

### matrices and arrays
As with atomic vectors, the dimension attribute can be used to create list-matrices and list-arrays. These are very rare data structures but they can be useful to arrange objects in a grid-like structure


## Data Frames and Tibbles
Data frame characteristics:
* it is a named list of vectors
* the vectors have attributes for column names, row names and its class ("data.frame")
* all vectors of the list must be the same length (unlike regular lists)

Tibbles are modern data frames. In short, they do less and complain more. They share the same structure as data frames. The only difference is the class vector: "tbl_df", which allows them to behave in different ways.

Tibbles are lazy:
* they do not coerce inputs (e.g. strings to factors)
* do not transform non-syntactic names
* only recycle values in a column, if the vector is of length one (i.e. the cells in the column can only take on one value)

### row names
Data frames are not like matrices. Data frames are not transposable. Rows and columns are not interchangeable.

Row names can be undesirable:
* metadata is data. Storing it in a different way to the rest of the data makes it harder to use
* row names are a poor abstraction for labelling rows because they only work when a row can be identified by a single string. Labelling and retrieving fails when you want to identify a row by a non-character vector or with multiple vectors
* row names must be unique

Due to the above reasons, tibbles do not support row names.

### subsetting
Tibbles are surly:
* subsetting with [] always returns a tibble
* subsetting with $ will only return a variable with the exact name. It does not perform partial matching as with data frames

using [["variable name"]] is the cleanest method for extracting a single column

### list columns
As a data frame is a list of vectors, it is possible for a column to be a list. And because a list can contain any other object, you can place any object in a data frame.

To place a list-column in a data frame, you need to add it after creating a data frame or by wrapping the list in `I()`.
To place a list-column in a tibble, you can add it during creation with `list()`.

### matrix and data frame columns
It is also possible to have a matrix or array as a column. Matrices and arrays must be added after the data frame is created or wrapped in `I()`. Many functions assume that all columns are vectors in a data frame so be careful when working with a matrix/data frame column.


## NULL
NULL is always length zero and never has attributes.

Two common uses of NULL:
* to represent an empty vector
* to represent an absent vector (NULL can be set as the default of an argument in a function)


# Subsetting
## Selecting Multiple Elements
[] is used to select any number of elements from a vector

### atmomic vectors
There are 6 things that you can use to subset a vector:
* positive integers
  * return elements at the specified positions
  * duplicate indices will duplicate values (i.e. obtain them more than once)
  * real numbers are silently truncated into integers
* negative integers
  * exclude elements at the specified positions
  * cannot be mixed with positive integer subsetting
* logical vectors
  * selects elements where the corresponding logical value is TRUE
  * e.g. `x[c(TRUE, TRUE, FALSE, FALSE)]` would return elements in the TRUE positions
  * e.g. `x[x > 3]` would return elements that meet the condition
  * when the length of the object and the vector differ, recycling rules are employed. This is convenient and easy to use when one of them have a length of one
* nothing/blank
  * x[]
  * returns the original vector
* zero
  * x[0]
  * returns a zero-length vector
* character vectors
  * x["name"]
  * returns elements with matching names
  * can subset for more than one vector c("name", "name")
  * factors aren't subsetted as factors, they are subsetted as integer vectors so that attribute will be lost in the output

### lists
Works in the same way as subsetting an atomic vector.
[] returns a list while [[]] and $ return elements

### matrices and arrays
Higher dimensional structures can be subset in three ways:
* multiple vectors
* single vectors
* matrix

The most common way of subsetting a >1D object is to supply a 1D index for each dimension separated by a comma. Blank subsetting here allows you to retain all the values in a dimension.

Subsetting with [] simplifies the result to the lowest possible dimensionality.

Matrices and arrays are just vectors with special attributes so they can be subsetted with a single vector as though they were a 1D vector. (reading of the vector goes column by column)
```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals
#>      [,1]  [,2]  [,3]  [,4]  [,5] 
#> [1,] "1,1" "1,2" "1,3" "1,4" "1,5"
#> [2,] "2,1" "2,2" "2,3" "2,4" "2,5"
#> [3,] "3,1" "3,2" "3,3" "3,4" "3,5"
#> [4,] "4,1" "4,2" "4,3" "4,4" "4,5"
#> [5,] "5,1" "5,2" "5,3" "5,4" "5,5"

vals[c(4, 15)]
#> [1] "4,1" "5,3"
```

Data structures with >1 dimension can be subsetted with an integer matrix (or a character matrix, if named). Each row in the matrix specifies the location of one value and each column corresponds to a dimension in the array. This means that a 2 column matrix can be used to subset a 2D object, a 3 column matrix for a 3D object, and so on.
```{r}
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1, # first value refers to first row and second value to first column
  3, 1,
  2, 4
))
vals[select]
#> [1] "1,1" "3,1" "2,4"
```

### data frames and tibbles
Data frames have the characteristics of both lists and matrices:
* when subsetting with a single index, they behave like lists and index the columns
* when subsetting with two indices, they behave like matrices

Note: matrix subsetting simplifies by default, list setting does not

Subsetting a tibble with [] always returns a tibble

### preserving dimensionality
Subsetting a matrix or data frame with a single number, name or logical vector containing one TRUE will simplify the returned output. To preserve dimensionality use `drop = FALSE`. This can be useful when you want to work on the output of a column with functions that require the input to be a data frame (rather than transforming it back to a data frame with `as.data.frame()`). 

Tibbles default to `drop = TRUE` so you don't need to worry about losing dimensionality with them.

## Selecting a Single Element
[[]] is used to extract single items. $ is a useful shorthand for [[]]

### [[]]
Using [] with a list returns a smaller list. [[]] returns the object within the specified item.

```{r}
x <- list(1:3, "a", 4:6)
x[1]
x[[1]]
```

[[]] can only return a single item so it must be used with a single positive integer or a single string. Using a vector with [[]] will subset recursively, i.e. `x[[c(1, 2)]]` is equivalent to `x[[1]][[2]]`.

### $
The one important difference between $ and [[]] is $ does partial matching. You can set `options(warnPartialMatchDollar = TRUE)` or use tibbles instead of data frames to avoid partial matching.

### @ and `slot()`
For S4 objects:
* @ = $ (more restrictive as it returns an error if the slot does not exist)
* `slot()` = [[]]

## Subsetting and Assignment
All subsetting operators can be combined with assignment to modify selected values of an input vector. `x[i] <- value`

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102)
x
#> [1] 101 102   3   4   5
```
Subassignment works best when the length of i is the same as the length of value (avoids recycling).

With lists, you can use `x[[i]] <- NULL` to remove a component. To add a literal NULL, use `x[i] <- list(NULL)`.

Subsetting with nothing can be useful with assignment because it preserves the original structure of the object.
```{r}
mtcars[] <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
#> [1] TRUE

mtcars <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
#> [1] FALSE
```


## Applications
### lookup tables
Character matching is a powerful way to create lookup tables
```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
#>        m        f        u        f        f        m        m 
#>   "Male" "Female"       NA "Female" "Female"   "Male"   "Male"
```

### matching and merging by hand
You can create more complex lookup tables with multiple columns of information
```{r}
grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

id <- match(grades, info$grade)
id
#> [1] 3 2 2 1 3
info[id, ]
#>     grade      desc  fail
#> 3       1      Poor  TRUE
#> 2       2      Good FALSE
#> 2.1     2      Good FALSE
#> 1       3 Excellent FALSE
#> 3.1     1      Poor  TRUE
```

### random samples and bootstraps
You can use integer indices to randomly sample or bootstrap a vector or data frame. Using `sample(n)`, you can generate a random permutation of 1:n and then use the results to subset the values.
```{r}
df <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])

# Randomly reorder
df[sample(nrow(df)), ]
#>   x y z
#> 5 2 1 e
#> 3 3 3 c
#> 4 1 2 d
#> 1 1 5 a
#> 2 2 4 b

# Select 3 random rows
df[sample(nrow(df), 3), ]
#>   x y z
#> 4 1 2 d
#> 2 2 4 b
#> 1 1 5 a

# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]
#>     x y z
#> 5   2 1 e
#> 5.1 2 1 e
#> 5.2 2 1 e
#> 2   2 4 b
#> 3   3 3 c
#> 3.1 3 3 c
```

#### ordering (integer subsetting)
`order()` takes a vector as an input and returns an integer vector describing how to order the subsetted vector
```{r}
x <- c("b", "c", "a")
order(x)
#> [1] 3 1 2
x[order(x)]
#> [1] "a" "b" "c"
```

For two or more dimensions, `order()` and integer subsetting makes it easy to order rows and columns of an object
```{r}
# Randomly reorder df
df2 <- df[sample(nrow(df)), 3:1]
df2
#>   z y x
#> 5 e 1 2
#> 1 a 5 1
#> 4 d 2 1
#> 2 b 4 2
#> 3 c 3 3

df2[order(df2$x), ]
#>   z y x
#> 1 a 5 1
#> 4 d 2 1
#> 5 e 1 2
#> 2 b 4 2
#> 3 c 3 3
df2[, order(names(df2))]
#>   x y z
#> 5 2 1 e
#> 1 1 5 a
#> 4 1 2 d
#> 2 2 4 b
#> 3 3 3 c
```

`sort()` can be used to do the same for vectors and `arrange()` for data frames

### expanding aggregated counts (integer subsetting)
`rep()` and integer subsetting make it easy to uncollapse a data frame where a count column has been added
```{r}
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
rep(1:nrow(df), df$n)
#> [1] 1 1 1 2 2 2 2 2 3

df[rep(1:nrow(df), df$n), ]
#>     x  y n
#> 1   2  9 3
#> 1.1 2  9 3
#> 1.2 2  9 3
#> 2   4 11 5
#> 2.1 4 11 5
#> 2.2 4 11 5
#> 2.3 4 11 5
#> 2.4 4 11 5
#> 3   1  6 1
```

### removing columns from data frames (character)
You can set a column to NULL or you can subset to return only the columns you want

### selecting rows based on a condition (logical subsetting)
Allows you to easily combine condition from multiple columns so it is a good way to extract rows from a data frame.
e.g. `df[df$column1 == value & df$column2 != value, ]


# Control Flow
## Choices
### vectorised if
`ifelse()` is a vectorised function with a test, yes and no vectors

`case_when()` is another vectorised if with a special syntax that allows any number of condition-vector pairs

### `switch()` statements
Closely related to if statements. Helps to make a block of if statements more concise.

E.g.
```{r}
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}
```
Can be replaced with:
```{r}
x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
```

The last component of a switch statement should throw an error otherwise unmatched inputs will invisibly return NULL outputs.

If multiple inputs have the same output, you can leave the right hand side of = empty and the output will assume the value of the next filled in output.
```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow")
#> [1] 4
legs("dog")
#> [1] 4
```

## Loops
Terminating a for loop early:
* next - exits the current iteration
* break - exits the entire loop
```{r}
for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
#> [1] 3
#> [1] 4
#> [1] 5
```

### common pitfalls
* if you're generating data, make sure you preallocate the output container. The vector function can be useful here
```{r}
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```
* beware of iterating over `1:length(x)`, especially if length(x) can equal 0. The loop will take i to be 1 and then 0 on the second loop. `seq_along()` is an alternative solution
* when iterating over S3 vectors, loops strip the attributes. Work around this with subsetting
```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (x in xs) {
  print(x)
}
#> [1] 18262
#> [1] 14610

for (i in seq_along(xs)) {
  print(xs[[i]])
}
#> [1] "2020-01-01"
#> [1] "2010-01-01"
```

### related tools
If you don't know the set of values you want to iterate over, you can use:
* `while(condition) action` - performs the action while condition is TRUE; an alternative to for loops
* `repeat(action)` - repeats the action until it encounters break; an alternative to while loops

Note: these alternatives are more flexible than loops


# Functions
Two things to remember:
* functions can be broken down into three components: arguments, body and environment
* functions are objects (in the same way vectors are objects)

## Function Fundamentals
Three parts (attributes) of a function:
* `formals()` - the list of arguments that control how you call the function
* `body()` - the code inside the function
* `environment()` - the data structure that determines how the function finds the values associated with the names

Formals and body are specified explicitly, environment is specified implicitly based on where you defined the function.

Functions can possess any number of additional attributes. E.g. srcref, which stands for source reference. It is similar to the body of a function but it also includes any comments written while creating the function.

### primitive functions
Primitive functions don't have the three components because they call C code directly. They have a type "builtin" or "special". Primitive functions are only found in the base package.

### first-class functions
First-class functions refers to when functions are objects

Typically functions are assigned names when they are created but this is not compulsory. You can create anonymous functions by not binding a name to them. This is useful when creating short functions that don't need to be named. E.g.
```{r}
lapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(x) ^ 2, 0, pi)
```

As functions are objects, they can be put into a list:
```{r}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
#> [1] 20
```

### invoking a function
Functions are normally called by placing its arguments in the function but if you have the arguments in a data structure already, you can use `do.call()`, which takes two arguments:
* the name of the function to call
* a list containing the arguments for that function

## Lexical Scoping
The act of finding a value associated with a name. R uses lexical scoping meaning it looks up the values of names based on how a function is defined, not how the function is called.

Four primary rules:
* name masking
  * names defined inside a function mask names defined outside a function
  * if a name isn't defined inside a function, R looks one level up (and so on until it reaches the global environment, at which point it'll look at other loaded packages)
* functions vs variables
  * the name masking rule applies to functions (because they are objects)
  * when a function and non-function share the same name, the application of rules is complex
  * just don't use the same names!
* a fresh start
  * every time a function is called, a new environment is created to host its execution
  * each invocation of a function is independent
* dynamic lookup
  * lexical scoping determines where to look for values but not when
  * when a function is created, lexical scoping doesn't come into effect
  * depending on the objects outside the function's environment, the output of a function can differ
  * for debugging: 
    * `codetools::findGlobals()` lists all the external dependencies of a function
    * `emptyenv()` changes the function's environment to one that contains nothing so you can find what dependency is missing

## Lazy Evaluation
Functions are only evaluated if accessed

### promises
Lazy evaluation is powered by a data structure called a promise. Promises have three components:
* an expression, which gives rise to the delayed computation
* an environment where the expression should be evaluated
* a value, which is computed and cached the first time a promise is accessed (when the expression is evaluated in the specified environment)

Promises cannot be manipulated with R code. If you try to inspect a promise, the expression will be evaluated.

### default arguments
Default values can be defined in terms of other arguments, including terms of variables defined later in the function. E.g.
```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

h04()
#> [1]   1   2 110
```

Defining terms based on variables that are defined later can make code hard to understand because you need to know the exact order in which default arguments are evaluated. The evaluation environment for default and user supplied arguments is slightly different. Default arguments are evaluated inside the function so calls that seem identical can have different outputs.

## dot-dot-dot
With ..., a function can take any number of additional arguments.

... can also be used to pass additional arguments from one function to another, e.g.
```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) { # i02 can take the arguments of i01
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
#> List of 2
#>  $ y: num 2
#>  $ z: num 3
```

Using ..N, it is possible to refer to elements of ... by position, e.g.
```{r}
i03 <- function(...) {
  list(first = ..1, third = ..3) # the arguments of list are passed onto i03
}
str(i03(1, 2, 3))
#> List of 2
#>  $ first: num 1
#>  $ third: num 3
```

`list(...)` can be used to evaluate arguments and store them in a list
```{r}
i04 <- function(...) {
  list(...)
}
i04(a = 1, b = 2)
#>  $ a 
#>  [1] 1
#>  $ b
#>  [2] 2
```

There are two main uses for ...:
* when a function takes a function as an argument, you may want to pass additional arguments. E.g. lapply uses ... to pass arguments of the function passed to it
* for S3 generic functions, you need a way to allow methods to take arbitrary extra arguments. E.g. print has a lot of different options for printing depending on the type of object. There's no way to pre-specify every possible argument so ... allows individual methods to have different arguments. (i.e. parameters of a function can vary according to the type of object)
```{r}
print(factor(letters), max.levels = 4)

print(y ~ x, showEnv = TRUE)
```

Disadvantages of ...:
* you have to carefully to the user where the arguments go and it can be difficult for users to understand the full potential of a function
* a mispelt argument will not raise an error

## Exiting a Function
### implicit vs explicit returns
When a function returns a value on exit, it does so implicitly or explicitly. An implicit return is where the last evaluated expression is returned and an explicit return is where `return()` is called.

### invisible values
Most functions return a value visibly but you can prevent the automatic printing of a value by applying `invisible()` to the last value. You can check that the value exists by printing it or wrapping it in (). Or, with `withVisible()`, which also returns a visbility flag (a logical value indicating if the result is visible or not).

### errors
When a function cannot complete its assigned function, it should throw up an error with `stop()` to terminate execution.

### exit handlers
Exit handlers are needed when a function changes the global state. Exit handlers ensure that those changes are only temporary by restoring the global state.

`on.exit(..., add = TRUE)` sets up an exit handler. Always set add = TRUE so that the exit handler that has just run doesn't overwrite the previous exit handler. `on.exit()` is useful because the cleanup code can be placed directly after the code that needs to be cleaned up. You don't need to do the clean up right at the end of the block.


## Function Forms
Everything that happens in R is a result of a function call. Function calls come in four varieties:
* prefix: the function name comes before its arguments
* infix: the function name comes in between its arguments (e.g. mathematical operators, pipes, etc)
* replacement: functions that replace values by assignment (e.g. names(df) <- c("a", "b"))
* special: functions that don't have a consistent structure (e.g. [[]], if, for, etc)

### rewriting to prefix form
Everything can be re-written to prefix form.
```{r}
x + y
`+`(x, y)

names(df) <- c("x", "y", "z")
`names<-`(df, c("x", "y", "z"))

for(i in 1:10) print(i)
`for`(i, 1:10, print(i))
```

Knowing the name of a non-prefix function allows you to override its behaviour.

### prefix form
You can specify arguments in three ways:
* by position
* with partial matching (using a part of the argument's name)
* by name (using the full name of an argument)

### infix functions
You can create infix functions that start and end with %. You create a two argument function and bind it to a name that starts and ends with %, e.g.
```{r}
`%+%` <- function(a, b) paste0(a, b)

"new " %+% "string"
#> [1] "new string"
```

If a line contains multiple infixes, they are evaluated left to right
```{r}
`%-%` <- function(a, b) paste0("(", a, " %-% ", b, ")")

"a" %-% "b" %-% "c"
#> [1] "((a %-% b) %-% c)"
```

"+" and "-" are special infix functions because they can be called with a single argument. They do not need a preceeding value/argument.

### replacement functions
Act like they modify their arguments in place. They have the special name "xxx<-" and must have arguments named x and value. E.g.
```{r}
`second<-` <- function(x, value) { # this function modifies the second element of a vector
  x[2] <- value
  x
}

x <- 1:10
second(x) <- 5L
x
#>  [1]  1  5  3  4  5  6  7  8  9 10
```

Replacement functions can be defined with other arguments. In this case, the additional arguments must be placed between x and value and in the call, the additional argument is passed on the left hand side, e.g.
```{r}
`modify<-` <- function(x, position, value) {
  x[position] <- value
  x
}
modify(x, 1) <- 10
x
#>  [1] 10  5  3  4  5  6  7  8  9 10
```

### special forms
Knowing the name of the function that underlies a special form is useful for getting the documentation. All special forms are implemented in C so printing them is not informative.


# Environments