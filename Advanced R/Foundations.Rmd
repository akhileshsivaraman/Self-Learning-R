---
title: 'Advanced R: Foundations'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

https://adv-r.hadley.nz/foundations-intro.html

# Vectors
## Atomic Vectors
4 primary types:
* logical
* integer
* double
* character

Integer and double vectors are collectively known as numeric vectors

### scalars
Each of the four primary vector types has a special syntax to create an individual value (scalar).

* logical: TRUE or FALSE
* doubles: decimal, scientific or hexadecimal numbers
  * also have three special values:
    * Inf
    * -Inf
    * NaN (not a number)
* integers: integers must be followed by L. They can be written in scientific and hexadecimal forms too
* strings/characters: surrounded by "". Special characters are escaped with "\"

### making longer vectors with `c()`
`c()` short for combine. If the inputs of `c()` are more atomic vectors, it flattens them.

You can determine the type of a vector with `typeof()` and length with `length()`.

### missing values
Represented with NA. Test for the presence of missingness with `is.na()`

### testing and coercion
`is.*()` functions to test if a vector is of a given type.

For atomic vectors, type is a property of the entire vector. All elements must be the same type. When you combine different types they are coerced in this order: characters -> double -> integer -> logical.

When logical vectors are coerced to numeric, TRUE = 1 and FALSE = 0.

Mathematical functions coerce automatically but you can deliberately coerce with `as.*()` functions. This can lead to the introduction of NAs where coercion is failed.


## Attributes
### getting and setting
Attributes can be thought of as name-value pairs that attach metadata to an object.
* `attr()`: sets and gets individual attributes
* `attributes()`: gets attributes en masse
* `structure()`: set en masse

Most attributes are lost through most operations. Only names and dimensions are routinely preserved. Names are character vectors giving each element a name and dim is an integer vector used to turn vectors into matrices or arrays.

### names
Ways to name a vector:
* when creating it: `x <- c(a = 1, b = 2, c = 3)`
* `names()`: `x <- 1:3`
              `names(x) <- c("a", "b", "c")`
* `setnames()`: `x <- setNames(1:3, c("a", "b", "c"))`

Remove names from a vector with `unname()` or `names(x) <- NULL`

### dimensions
Adding a dim attribute allows a vector to behave like a 2D matrix or a multi-dimensional array. 

Ways to create matrices and arrays:
* `matrix()`
* `array()`
* `dim()`

Many of the functions for working with vectors have equivalents for matrices and arrays. E.g. names() for vectors and rownames() and colnames() for matrices and dimnames() for arrays.


## S3 Atomic Vectors
The class attribute: having one turns an object into an S3 object. S3 objects behave differently when passed to a generic function. Every S3 object is built on top of a base type and often stores additional information in other attributes.

Four common S3 vectors:
* categorical vectors: where values comes from a fixed set of levels recorded in factor vectors
* dates: recorded in date vectors
* date-times: POSIXct vectors
* durations: difftime vectors

### factors
Characteristics:
* a vector that can only take a predefined value
* used to store categorical vectors
* built on top of an integer vector
* has two attributes:
  * class: "factor", makes it behave differently from regular integer vectors
  * levels: defines the set of allowed values

Factors are useful when you know the set of possible values but they're not all present in the dataset. Some base R functions automatically convert character vectors to categorical vectors/factors. But, they do this without knowing the full set of values the data can assume. It is better to manually set character vectors to factors with your knowledge of all the theoretical values that can be taken. You can suppress the conversion with `stringsAsFactors = FALSE`.

Factors are built on top of integers so be careful when treating them like strings. Some functions recognise this and automatically coerce factors to strings, others don't. It is best to explicitly convert factors to character vectors before manipulating them like strings.

### dates
Characteristics:
* built on top of double vectors
* only one attribute
  * class: "Date"

The value of the double can viewed by removing the class with `unclass()` and it represent the number of days since 1970-01-01. 

### date-times
Characteristics:
* built on top of double vectors (the value of the double represent the number of seconds since 1970-01-01)
* attributes:
  * class: "POSIXct" or "POSIXlt"
  * tzone: time zone which affects how the time is printed

### durations
Characteristics:
* represent the amount of time between pairs of dates or date-times
* built on top of doubles
* attributes:
  * class: "difftime:
  * units: unit of time


## Lists
* each element of a list can be of any type, not just a vector
* elements of a list are references (not copies of components) so the size of a list is much smaller than might be expected
* recursive - can contain other lists
  * `c()` will combine several lists into one
  * this property makes them fundamentally different from atomic vectors

### matrices and arrays
As with atomic vectors, the dimension attribute can be used to create list-matrices and list-arrays. These are very rare data structures but they can be useful to arrange objects in a grid-like structure


## Data Frames and Tibbles
Data frame characteristics:
* it is a named list of vectors
* the vectors have attributes for column names, row names and its class ("data.frame")
* all vectors of the list must be the same length (unlike regular lists)

Tibbles are modern data frames. In short, they do less and complain more. They share the same structure as data frames. The only difference is the class vector: "tbl_df", which allows them to behave in different ways.

Tibbles are lazy:
* they do not coerce inputs (e.g. strings to factors)
* do not transform non-syntactic names
* only recycle values in a column, if the vector is of length one (i.e. the cells in the column can only take on one value)

### row names
Data frames are not like matrices. Data frames are not transposable. Rows and columns are not interchangeable.

Row names can be undesirable:
* metadata is data. Storing it in a different way to the rest of the data makes it harder to use
* row names are a poor abstraction for labelling rows because they only work when a row can be identified by a single string. Labelling and retrieving fails when you want to identify a row by a non-character vector or with multiple vectors
* row names must be unique

Due to the above reasons, tibbles do not support row names.

### subsetting
Tibbles are surly:
* subsetting with [] always returns a tibble
* subsetting with $ will only return a variable with the exact name. It does not perform partial matching as with data frames

using [["variable name"]] is the cleanest method for extracting a single column

### list columns
As a data frame is a list of vectors, it is possible for a column to be a list. And because a list can contain any other object, you can place any object in a data frame.

To place a list-column in a data frame, you need to add it after creating a data frame or by wrapping the list in `I()`.
To place a list-column in a tibble, you can add it during creation with `list()`.

### matrix and data frame columns
It is also possible to have a matrix or array as a column. Matrices and arrays must be added after the data frame is created or wrapped in `I()`. Many functions assume that all columns are vectors in a data frame so be careful when working with a matrix/data frame column.


## NULL
NULL is always length zero and never has attributes.

Two common uses of NULL:
* to represent an empty vector
* to represent an absent vector (NULL can be set as the default of an argument in a function)


# Subsetting
## Selecting Multiple Elements
[] is used to select any number of elements from a vector

### atmomic vectors
There are 6 things that you can use to subset a vector:
* positive integers
  * return elements at the specified positions
  * duplicate indices will duplicate values (i.e. obtain them more than once)
  * real numbers are silently truncated into integers
* negative integers
  * exclude elements at the specified positions
  * cannot be mixed with positive integer subsetting
* logical vectors
  * selects elements where the corresponding logical value is TRUE
  * e.g. `x[c(TRUE, TRUE, FALSE, FALSE)]` would return elements in the TRUE positions
  * e.g. `x[x > 3]` would return elements that meet the condition
  * when the length of the object and the vector differ, recycling rules are employed. This is convenient and easy to use when one of them have a length of one
* nothing/blank
  * x[]
  * returns the original vector
* zero
  * x[0]
  * returns a zero-length vector
* character vectors
  * x["name"]
  * returns elements with matching names
  * can subset for more than one vector c("name", "name")
  * factors aren't subsetted as factors, they are subsetted as integer vectors so that attribute will be lost in the output

### lists
Works in the same way as subsetting an atomic vector.
[] returns a list while [[]] and $ return elements

### matrices and arrays
Higher dimensional structures can be subset in three ways:
* multiple vectors
* single vectors
* matrix

The most common way of subsetting a >1D object is to supply a 1D index for each dimension separated by a comma. Blank subsetting here allows you to retain all the values in a dimension.

Subsetting with [] simplifies the result to the lowest possible dimensionality.

Matrices and arrays are just vectors with special attributes so they can be subsetted with a single vector as though they were a 1D vector. (reading of the vector goes column by column)
```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals
#>      [,1]  [,2]  [,3]  [,4]  [,5] 
#> [1,] "1,1" "1,2" "1,3" "1,4" "1,5"
#> [2,] "2,1" "2,2" "2,3" "2,4" "2,5"
#> [3,] "3,1" "3,2" "3,3" "3,4" "3,5"
#> [4,] "4,1" "4,2" "4,3" "4,4" "4,5"
#> [5,] "5,1" "5,2" "5,3" "5,4" "5,5"

vals[c(4, 15)]
#> [1] "4,1" "5,3"
```

Data structures with >1 dimension can be subsetted with an integer matrix (or a character matrix, if named). Each row in the matrix specifies the location of one value and each column corresponds to a dimension in the array. This means that a 2 column matrix can be used to subset a 2D object, a 3 column matrix for a 3D object, and so on.
```{r}
select <- matrix(ncol = 2, byrow = TRUE, c(
  1, 1, # first value refers to first row and second value to first column
  3, 1,
  2, 4
))
vals[select]
#> [1] "1,1" "3,1" "2,4"
```

### data frames and tibbles
Data frames have the characteristics of both lists and matrices:
* when subsetting with a single index, they behave like lists and index the columns
* when subsetting with two indices, they behave like matrices

Note: matrix subsetting simplifies by default, list setting does not

Subsetting a tibble with [] always returns a tibble

### preserving dimensionality
Subsetting a matrix or data frame with a single number, name or logical vector containing one TRUE will simplify the returned output. To preserve dimensionality use `drop = FALSE`. This can be useful when you want to work on the output of a column with functions that require the input to be a data frame (rather than transforming it back to a data frame with `as.data.frame()`). 

Tibbles default to `drop = TRUE` so you don't need to worry about losing dimensionality with them.

## Selecting a Single Element
[[]] is used to extract single items. $ is a useful shorthand for [[]]

### [[]]
Using [] with a list returns a smaller list. [[]] returns the object within the specified item.

```{r}
x <- list(1:3, "a", 4:6)
x[1]
x[[1]]
```

[[]] can only return a single item so it must be used with a single positive integer or a single string. Using a vector with [[]] will subset recursively, i.e. `x[[c(1, 2)]]` is equivalent to `x[[1]][[2]]`.

### $
The one important difference between $ and [[]] is $ does partial matching. You can set `options(warnPartialMatchDollar = TRUE)` or use tibbles instead of data frames to avoid partial matching.

### @ and `slot()`
For S4 objects:
* @ = $ (more restrictive as it returns an error if the slot does not exist)
* `slot()` = [[]]

## Subsetting and Assignment
All subsetting operators can be combined with assignment to modify selected values of an input vector. `x[i] <- value`

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102)
x
#> [1] 101 102   3   4   5
```
Subassignment works best when the length of i is the same as the length of value (avoids recycling).

With lists, you can use `x[[i]] <- NULL` to remove a component. To add a literal NULL, use `x[i] <- list(NULL)`.

Subsetting with nothing can be useful with assignment because it preserves the original structure of the object.
```{r}
mtcars[] <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
#> [1] TRUE

mtcars <- lapply(mtcars, as.integer)
is.data.frame(mtcars)
#> [1] FALSE
```


## Applications
### lookup tables
Character matching is a powerful way to create lookup tables
```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
#>        m        f        u        f        f        m        m 
#>   "Male" "Female"       NA "Female" "Female"   "Male"   "Male"
```

### matching and merging by hand
You can create more complex lookup tables with multiple columns of information
```{r}
grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

id <- match(grades, info$grade)
id
#> [1] 3 2 2 1 3
info[id, ]
#>     grade      desc  fail
#> 3       1      Poor  TRUE
#> 2       2      Good FALSE
#> 2.1     2      Good FALSE
#> 1       3 Excellent FALSE
#> 3.1     1      Poor  TRUE
```

### random samples and bootstraps
You can use integer indices to randomly sample or bootstrap a vector or data frame. Using `sample(n)`, you can generate a random permutation of 1:n and then use the results to subset the values.
```{r}
df <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])

# Randomly reorder
df[sample(nrow(df)), ]
#>   x y z
#> 5 2 1 e
#> 3 3 3 c
#> 4 1 2 d
#> 1 1 5 a
#> 2 2 4 b

# Select 3 random rows
df[sample(nrow(df), 3), ]
#>   x y z
#> 4 1 2 d
#> 2 2 4 b
#> 1 1 5 a

# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]
#>     x y z
#> 5   2 1 e
#> 5.1 2 1 e
#> 5.2 2 1 e
#> 2   2 4 b
#> 3   3 3 c
#> 3.1 3 3 c
```

#### ordering (integer subsetting)
`order()` takes a vector as an input and returns an integer vector describing how to order the subsetted vector
```{r}
x <- c("b", "c", "a")
order(x)
#> [1] 3 1 2
x[order(x)]
#> [1] "a" "b" "c"
```

For two or more dimensions, `order()` and integer subsetting makes it easy to order rows and columns of an object
```{r}
# Randomly reorder df
df2 <- df[sample(nrow(df)), 3:1]
df2
#>   z y x
#> 5 e 1 2
#> 1 a 5 1
#> 4 d 2 1
#> 2 b 4 2
#> 3 c 3 3

df2[order(df2$x), ]
#>   z y x
#> 1 a 5 1
#> 4 d 2 1
#> 5 e 1 2
#> 2 b 4 2
#> 3 c 3 3
df2[, order(names(df2))]
#>   x y z
#> 5 2 1 e
#> 1 1 5 a
#> 4 1 2 d
#> 2 2 4 b
#> 3 3 3 c
```

`sort()` can be used to do the same for vectors and `arrange()` for data frames

### expanding aggregated counts (integer subsetting)
`rep()` and integer subsetting make it easy to uncollapse a data frame where a count column has been added
```{r}
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
rep(1:nrow(df), df$n)
#> [1] 1 1 1 2 2 2 2 2 3

df[rep(1:nrow(df), df$n), ]
#>     x  y n
#> 1   2  9 3
#> 1.1 2  9 3
#> 1.2 2  9 3
#> 2   4 11 5
#> 2.1 4 11 5
#> 2.2 4 11 5
#> 2.3 4 11 5
#> 2.4 4 11 5
#> 3   1  6 1
```

### removing columns from data frames (character)
You can set a column to NULL or you can subset to return only the columns you want

### selecting rows based on a condition (logical subsetting)
Allows you to easily combine condition from multiple columns so it is a good way to extract rows from a data frame.
e.g. `df[df$column1 == value & df$column2 != value, ]


# Control Flow
## Choices
### vectorised if
`ifelse()` is a vectorised function with a test, yes and no vectors

`case_when()` is another vectorised if with a special syntax that allows any number of condition-vector pairs

### `switch()` statements
Closely related to if statements. Helps to make a block of if statements more concise.

E.g.
```{r}
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}
```
Can be replaced with:
```{r}
x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
```

The last component of a switch statement should throw an error otherwise unmatched inputs will invisibly return NULL outputs.

If multiple inputs have the same output, you can leave the right hand side of = empty and the output will assume the value of the next filled in output.
```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow")
#> [1] 4
legs("dog")
#> [1] 4
```

## Loops
Terminating a for loop early:
* next - exits the current iteration
* break - exits the entire loop
```{r}
for (i in 1:10) {
  if (i < 3) 
    next

  print(i)
  
  if (i >= 5)
    break
}
#> [1] 3
#> [1] 4
#> [1] 5
```

### common pitfalls
* if you're generating data, make sure you preallocate the output container. The vector function can be useful here
```{r}
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```
* beware of iterating over `1:length(x)`, especially if length(x) can equal 0. The loop will take i to be 1 and then 0 on the second loop. `seq_along()` is an alternative solution
* when iterating over S3 vectors, loops strip the attributes. Work around this with subsetting
```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (x in xs) {
  print(x)
}
#> [1] 18262
#> [1] 14610

for (i in seq_along(xs)) {
  print(xs[[i]])
}
#> [1] "2020-01-01"
#> [1] "2010-01-01"
```

### related tools
If you don't know the set of values you want to iterate over, you can use:
* `while(condition) action` - performs the action while condition is TRUE; an alternative to for loops
* `repeat(action)` - repeats the action until it encounters break; an alternative to while loops

Note: these alternatives are more flexible than loops


# Functions
Two things to remember:
* functions can be broken down into three components: arguments, body and environment
* functions are objects (in the same way vectors are objects)

## Function Fundamentals
Three parts (attributes) of a function:
* `formals()` - the list of arguments that control how you call the function
* `body()` - the code inside the function
* `environment()` - the data structure that determines how the function finds the values associated with the names

Formals and body are specified explicitly, environment is specified implicitly based on where you defined the function.

Functions can possess any number of additional attributes. E.g. srcref, which stands for source reference. It is similar to the body of a function but it also includes any comments written while creating the function.

### primitive functions
Primitive functions don't have the three components because they call C code directly. They have a type "builtin" or "special". Primitive functions are only found in the base package.

### first-class functions
First-class functions refers to when functions are objects

Typically functions are assigned names when they are created but this is not compulsory. You can create anonymous functions by not binding a name to them. This is useful when creating short functions that don't need to be named. E.g.
```{r}
lapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(x) ^ 2, 0, pi)
```

As functions are objects, they can be put into a list:
```{r}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
#> [1] 20
```

### invoking a function
Functions are normally called by placing its arguments in the function but if you have the arguments in a data structure already, you can use `do.call()`, which takes two arguments:
* the name of the function to call
* a list containing the arguments for that function

## Lexical Scoping
The act of finding a value associated with a name. R uses lexical scoping meaning it looks up the values of names based on how a function is defined, not how the function is called.

Four primary rules:
* name masking
  * names defined inside a function mask names defined outside a function
  * if a name isn't defined inside a function, R looks one level up (and so on until it reaches the global environment, at which point it'll look at other loaded packages)
* functions vs variables
  * the name masking rule applies to functions (because they are objects)
  * when a function and non-function share the same name, the application of rules is complex
  * just don't use the same names!
* a fresh start
  * every time a function is called, a new environment is created to host its execution
  * each invocation of a function is independent
* dynamic lookup
  * lexical scoping determines where to look for values but not when
  * when a function is created, lexical scoping doesn't come into effect
  * depending on the objects outside the function's environment, the output of a function can differ
  * for debugging: 
    * `codetools::findGlobals()` lists all the external dependencies of a function
    * `emptyenv()` changes the function's environment to one that contains nothing so you can find what dependency is missing

## Lazy Evaluation
Functions are only evaluated if accessed

### promises
Lazy evaluation is powered by a data structure called a promise. Promises have three components:
* an expression, which gives rise to the delayed computation
* an environment where the expression should be evaluated
* a value, which is computed and cached the first time a promise is accessed (when the expression is evaluated in the specified environment)

Promises cannot be manipulated with R code. If you try to inspect a promise, the expression will be evaluated.

### default arguments
Default values can be defined in terms of other arguments, including terms of variables defined later in the function. E.g.
```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

h04()
#> [1]   1   2 110
```

Defining terms based on variables that are defined later can make code hard to understand because you need to know the exact order in which default arguments are evaluated. The evaluation environment for default and user supplied arguments is slightly different. Default arguments are evaluated inside the function so calls that seem identical can have different outputs.

## dot-dot-dot
With ..., a function can take any number of additional arguments.

... can also be used to pass additional arguments from one function to another, e.g.
```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) { # i02 can take the arguments of i01
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
#> List of 2
#>  $ y: num 2
#>  $ z: num 3
```

Using ..N, it is possible to refer to elements of ... by position, e.g.
```{r}
i03 <- function(...) {
  list(first = ..1, third = ..3) # the arguments of list are passed onto i03
}
str(i03(1, 2, 3))
#> List of 2
#>  $ first: num 1
#>  $ third: num 3
```

`list(...)` can be used to evaluate arguments and store them in a list
```{r}
i04 <- function(...) {
  list(...)
}
i04(a = 1, b = 2)
#>  $ a 
#>  [1] 1
#>  $ b
#>  [2] 2
```

There are two main uses for ...:
* when a function takes a function as an argument, you may want to pass additional arguments. E.g. lapply uses ... to pass arguments of the function passed to it
* for S3 generic functions, you need a way to allow methods to take arbitrary extra arguments. E.g. print has a lot of different options for printing depending on the type of object. There's no way to pre-specify every possible argument so ... allows individual methods to have different arguments. (i.e. parameters of a function can vary according to the type of object)
```{r}
print(factor(letters), max.levels = 4)

print(y ~ x, showEnv = TRUE)
```

Disadvantages of ...:
* you have to carefully explain to the user where the arguments go and it can be difficult for users to understand the full potential of a function
* a mispelt argument will not raise an error

## Exiting a Function
### implicit vs explicit returns
When a function returns a value on exit, it does so implicitly or explicitly. An implicit return is where the last evaluated expression is returned and an explicit return is where `return()` is called.

### invisible values
Most functions return a value visibly but you can prevent the automatic printing of a value by applying `invisible()` to the last value. You can check that the value exists by printing it or wrapping it in (). Or, with `withVisible()`, which also returns a visbility flag (a logical value indicating if the result is visible or not).

### errors
When a function cannot complete its assigned function, it should throw up an error with `stop()` to terminate execution.

### exit handlers
Exit handlers are needed when a function changes the global state. Exit handlers ensure that those changes are only temporary by restoring the global state.

`on.exit(..., add = TRUE)` sets up an exit handler. Always set add = TRUE so that the exit handler that has just run doesn't overwrite the previous exit handler. `on.exit()` is useful because the cleanup code can be placed directly after the code that needs to be cleaned up. You don't need to do the clean up right at the end of the block.


## Function Forms
Everything that happens in R is a result of a function call. Function calls come in four varieties:
* prefix: the function name comes before its arguments
* infix: the function name comes in between its arguments (e.g. mathematical operators, pipes, etc)
* replacement: functions that replace values by assignment (e.g. names(df) <- c("a", "b"))
* special: functions that don't have a consistent structure (e.g. [[]], if, for, etc)

### rewriting to prefix form
Everything can be re-written to prefix form.
```{r}
x + y
`+`(x, y)

names(df) <- c("x", "y", "z")
`names<-`(df, c("x", "y", "z"))

for(i in 1:10) print(i)
`for`(i, 1:10, print(i))
```

Knowing the name of a non-prefix function allows you to override its behaviour.

### prefix form
You can specify arguments in three ways:
* by position
* with partial matching (using a part of the argument's name)
* by name (using the full name of an argument)

### infix functions
You can create infix functions that start and end with %. You create a two argument function and bind it to a name that starts and ends with %, e.g.
```{r}
`%+%` <- function(a, b) paste0(a, b)

"new " %+% "string"
#> [1] "new string"
```

If a line contains multiple infixes, they are evaluated left to right
```{r}
`%-%` <- function(a, b) paste0("(", a, " %-% ", b, ")")

"a" %-% "b" %-% "c"
#> [1] "((a %-% b) %-% c)"
```

"+" and "-" are special infix functions because they can be called with a single argument. They do not need a preceeding value/argument.

### replacement functions
Act like they modify their arguments in place. They have the special name "xxx<-" and must have arguments named x and value. E.g.
```{r}
`second<-` <- function(x, value) { # this function modifies the second element of a vector
  x[2] <- value
  x
}

x <- 1:10
second(x) <- 5L
x
#>  [1]  1  5  3  4  5  6  7  8  9 10
```

Replacement functions can be defined with other arguments. In this case, the additional arguments must be placed between x and value and in the call, the additional argument is passed on the left hand side, e.g.
```{r}
`modify<-` <- function(x, position, value) {
  x[position] <- value
  x
}
modify(x, 1) <- 10
x
#>  [1] 10  5  3  4  5  6  7  8  9 10
```

### special forms
Knowing the name of the function that underlies a special form is useful for getting the documentation. All special forms are implemented in C so printing them is not informative.


# Environments
The environment is the data structure that powers scoping
```{r}
library(rlang)
```

## Environment Basics
An environment is similar to a named list with four exceptions:
* every name must be unique
* names in an environment are not ordered
* an environment has a parent
* environments are not copied when modified

### basics
`rlang::env()` creates an environment. It takes a set of name-value pairs
```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)
```

`new.env()` also creates a new environment. (hash and size parameters can be ignored)

The job of a new environment is to bind a set of names to a set of values. An environment is like a bag of names with no order (there is no first element and so on).

Environments can contain themselves because they are not copied when modified.

`env_print()` tells us about an environment and `env_names()` gives us a character vector with the current bindings
```{r}
env_print(e1)

env_names(e1)
```

### important environments
The current environment is the environment in which code is currently being executed. This is usually the global environment, where all interactive (i.e. outside of a function) computation takes place.

To compare environments use `identical()` rather than `==` because environments are not vectors.

### parents
The parent of an environment is another environment. Parents are used to implement lexical scoping whereby if a name is not found in an environment, R will look at its parents and so on.

You can set the parent environment by supplying an unnamed argument to `env()`. If there is no parent supplied, it defaults to the current environment
```{r}
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3) # e2a is the parent of e2b
```

`env_parent()` finds the parent of a given environment

The only environment that doesn't have a parent is the empty environment. `env_parents()` shows you all the ancestors of a given environment up to, but not including, the empty environment. It stops at the global environment where you'll see every attached package.

### super assignment <<-
<- creates a variable in the current environment
<<- modifies an existing variable found in a parent environment
If an existing variable is not found, it creates one in the global environment

### getting and setting
You can get and set elements of an environment with $ and [[]]. But [[]] cannot be used with indices (has to be named/character) and you cannot use []

Two other ways to add bindings to an environment:
* `env_poke()`: takes a name and a value
```{r}
env_poke(e3, "a", 100)
e3$a
#> [1] 100
```
* `env_bind()`: allows you to bind multiple values
```{r}
env_bind(e3, a = 10, b = 20)
env_names(e3)
#> [1] "x" "y" "z" "a" "b"
```

You can determine if an environment has a binding with `env_has()`

Unlike lists, setting an element to NULL does not remove it because sometimes you want a name that refers to NULL. `env_unbind()` "removes" but doesn't delete an object
```{r}
e3$a <- NULL
env_has(e3, "a")
#>    a 
#> TRUE

env_unbind(e3, "a")
env_has(e3, "a")
#>     a 
#> FALSE
```

### advanced bindings
There are two vairants of `env_bind()`:
* `env_bind_lazy()`: creates delayed bindings, which are evaluated the first time they are accessed. Delayed bindings create promises so behave like function arguments
```{r}
env_bind_lazy(current_env(), b = {Sys.sleep(1); 1})

system.time(print(b)) # b is accessed for the first time here
#> [1] 1
#>    user  system elapsed 
#>    0.00    0.00    1.09
system.time(print(b)) # b already exists so no delay
#> [1] 1
#>    user  system elapsed 
#>       0       0       0
```
The primary use of delayed bindings is in autoload(), which allows R packages to provide datasets that behave like they are loaded in memory, even though theyâ€™re only loaded from disk when needed.
* `env_bind_active()`: creates active bindings which are re-computed every time they are accessed. They are used to implement R6's active fields


## Recursing Over Environments
To operate on every ancestor of an environment, it is convenient to write a recursive function `where()`, which takes two arguments:
* the name to look for as a string
* the environment in which to start the search

```{r}
where <- function(name, env = caller_env()) { # caller_env() is set as the default to use the current environment
  if (identical(env, empty_env())) {# Base case: we've reached the empty environment and cannot find the binding
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name)) {# Success case: the name exists in this environment
    env
  } else { # Recursive case: the name was not found in this environment, try the parent environment
    where(name, env_parent(env))
  }
}
```
`where()` in use
```{r}
where("yyy")
#> Error: Can't find yyy

x <- 5
where("x")
#> <environment: R_GlobalEnv>

where("mean")
#> <environment: base>
```

## Special Environments
Most environments are created by R

### package environments and the search path
Each package attached by `library()` becomes one of the ancestors of the global environment. The immediate parent of the global environment is the last attached package, the parent of that package is the package attached before that and so on. If you follow all the packages/parents back, you see the order in which they were attached. This is the search path.

You can view the search path with `base::search()` or `rlang::search_envs()`. The last two environments on the search path are always the same:
* autoloads - an environment that uses delayed bindings to save memory
* package:base - also known as base, it is the environment of the base package. It bootstraps the loading of all other packages.

### the function environment
Function environment = the current environment to which a function binds when it is created. You can get the function environment with `fn_env()`

A function is bound by an environment telling us where to find it and it binds to a function telling us where it find its variables.

### namespaces
Namespaces ensure that packages can find the right functions even if they have been loaded in different orders (and the ancestry of the environments changes). Every function in a package is associated with a pair of environments:
* the package environment - the external interface of the package. This is how users find the function in a package
* the namespace environment - the internal interface of the package, which controls how the function finds its variables

Every namespace environment has the same set of ancestors:
* imports environment - contains bindings to all the functions used by the package
* base namespace environment - contains the same bindings as the base environment but it has a different parent
* global environment - if a binding cannot be found in the imports or the base namespace environments, R looks in the global environment. But this means the code will depend on other loaded packages. R will automatically check and warn about these dependencies. It is unusual for it to be a problem nowadays so this ancestor mainly exists for historical reasons

### execution environments
Each time a function is called, a new environment is created. The execution environment is the child of the function environment and it is usually ephemeral. The execution environment is garbage collected once execution has finished.

But you can make the execution environment stick around for longer:
* by explicitly returning it
```{r}
h2 <- function(x) {
  a <- x * 2
  current_env()
}

e <- h2(x = 10)
env_print(e)
#> <environment: 0x7fe6c8502738>
#> parent: <environment: global>
#> bindings:
#>  * a: <dbl>
#>  * x: <dbl>
fn_env(h2)
#> <environment: R_GlobalEnv>
```
* by returning an object with a binding to that environment
```{r}
plus <- function(x) {
  function(y) x + y
}

plus_one <- plus(1)
plus_one
#> function(y) x + y
#> <environment: 0x7fe6c6cd3ad8>

# the execution environment of plus_one() will capture the execution environment of plus() as its parent
```


## Call Stacks
The caller environment accessed with `rlang::caller_env()`. The caller environment is the environment from which a function is called. It varies based on how the function is called, not how the function was created.

When a function is called, an execution environment is created and a call stack is created.

### simple call stacks
A call stack can be viewed by using `traceback()` or `lobstr::cst()`. cst() produces a call stack tree

### lazy evaluation
A call stack tree is useful when calls happen on different branches (i.e. not one linear process) and is indicative of lazy evaluation

### frames
Each element of a call stack is a frame (also called an evaluation context). A frame has three important components:
* an expression - gives the function call (what traceback prints out)
* an environment - typically the execution environment of a function (except for the global frame which belongs to the global environment)
* a parent - the previous call in the stack

### dynamic scope
Dynamic scoping = looking up variables in the call stack rather than in the enclosing environment

Dynamic scoping is rare in programming languages because it makes it much harder to reason about how a function operates - you need to know how a function is defined and the context in which it was called

The main use for dynamic scoping is developing functions that aid interactive data analysis.


## As Data Structures
Environments are also data structures (they're not just there for scoping). They have reference semantics which means they can help solve:
* avoiding copies of large data - as environments have reference semantics, you'll never accidentally create a copy
* managing state within a package - explicit environments are useful in packages because they allow you to maintain state across function calls. You can modify objects in a package indirectly like this.
```{r}
my_env <- new.env(parent = emptyenv())
my_env$a <- 1

get_a <- function() {
  my_env$a
}
set_a <- function(value) {
  old <- my_env$a
  my_env$a <- value
  invisible(old)
}
```
* as a hashmap - a data structure that takes constant, O(1), time to find an object based on its name. Environments provide this behaviour by default, so can be used to simulate a hashmap


# Conditions
The condition system provides a set of tools that allow the author of a function to indicate that something unusual is happening and the user of the function to deal with it.

Conditions are signalled with functions like:
* `stop()` for errors
* `warning()` for warnings
* `message()` for messages

The user can handle them with functions like `tryCatch()` and `withCallingHandlers()`

```{r}
library(rlang)
```

## Signalling Conditions
Three conditions that you can signal:
* errors - signal that there is no way for a function to continue and execution must stop
* warnings - indicate that something has gone wrong but the function can recover
* messages - inform the user that some action has been performed on their behalf

### errors
`stop()` generates errors. It typically includes the call but this can be turned off with `call. = FALSE` parameter. `rlang::abort()` also generates errors and does so without the call but it cannot put together complex error messages (which stop() can)

Writing error messages in your functions is difficult but ideally they tell the user what is wrong and point them in the right direction to fix it

### warnings
`warning()` to create warnings (or `rlang::warn()`)

You can have multiple warnings in a single function call and by default, the warnings will be cached and printed at the end of execution

Warnings are best used to flag:
* when you deprecate a function and want to encourage users to use the new function
* when you are reasonably certain a function can recover from a problem

Best to use warnings with restraint as errors or messages are often more appropriate

### messages
`message()` to create messages to keep the user informed

Messages are informational and are good to use:
* when a default argument requires a non-trivial amount of computation and you want to tell the user what value was used by default (or user-selected)
* in functions that are called primarily for their side effects which would be silent (using messages to tell the user what's happening)
* when you're starting a long running process with no intermediate output (progress bars are a better option)
* when you want to display a message when your package has loaded (use `packageStartupMessage()` instead)

## Ignoring Conditions
Wrap code with the following functions to ignore conditions:

* ignore errors with `try()`
  * allows execution to continue even after an error has occurred
  * it can be useful to do assignment inside try() because it lets you define a default value if the code does not succeed
```{r}
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
```

* ignore warnings with `suppressWarnings()`
* ignore messages with `suppressMessages()`

## Handling Conditions
Condition handlers allow us to temporarily override default behaviours of conditions

Registration functions: `tryCatch()` and `withCallingHandlers()`. They take the signalled condition as their argument
Syntax has the same basic form:
```{r}
tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning is signalled
  },
  message = function(cnd) {
    # code to run when message is signalled
  },
  code_to_run_while_handlers_are_active
)
```

`tryCatch()` defines exiting handlers. After the condition is handled, control returns to the context where tryCatch() was called

`withCallingHandlers()` defines calling handlers. After the condition is captured control returns to the context where the condition was signalled

### condition objects
Created implicitly when a condition is signalled but become explicit when inside the handler

`rlang::catch_cnd()` catches a condition object created by a signalled condition
```{r}
cnd <- catch_cnd(stop("An error"))
str(cnd)
#> List of 2
#>  $ message: chr "An error"
#>  $ call   : language force(expr)
#>  - attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
```

Built-in conditions are lists with two elements:
* message - a character vector containing the text to display to the user
* call - the called that triggered the condition (note: it is usually NULL)

Conditions have a class attribute too so they are actually S3 objects

### exit handlers
`tryCatch()` registers exiting handlers and is typically used to handle error conditions. It can be used to override default error behaviour
```{r}
f3 <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    log(x)
  )
}

f3("x")
#> [1] NA
# NA returned rather than throwing an error
```

If no conditions are signalled or the class of the signalled condition does not match the handler name, the code executes normally. 

After a condition is signalled in tryCatch(), control passes to the handler and never returns to the original code, effectively meaning that the code exits. The protected code is evaluated in the environment of tryCatch() but the handler code is not. Handler functions are called with a single argument, the condition object. By convention the argument is called "cnd"

tryCatch() has one other argument: finally, which specifies a block of code to run regardless of whether the initial expression succeeds or fails. This is functionally similar to on.exit()

### calling handlers
`withCallingHandlers()` sets up calling handlers: code execution continues as normal once the handler returns

Calling and exit handlers are slightly different:
* exiting handlers handle a signal like you handle a problem, you make it go away
* calling handlers handl a signal like you handle a car, the car still exists
```{r}
tryCatch(
  message = function(cnd) cat("Caught a message!\n"), 
  { # this block is not run because the code is terminated once the exiting handler completes
    message("Someone there?")
    message("Why, yes!")
  }
)
#> Caught a message!

withCallingHandlers(
  message = function(cnd) cat("Caught a message!\n"), 
  { # this block is run because a calling handler does not exit
    message("Someone there?")
    message("Why, yes!")
  }
)
#> Caught a message!
#> Someone there?
#> Caught a message!
#> Why, yes!
```

One important side-effect unique to calling handlers is the ability to muffle the signal. By default, a condition will continue to propagate to parent handlers all the way up to the default handler:
```{r}
# Bubbles all the way up to default handler which generates the message
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)
#> Level 1
#> Level 2
#> Hello

# Bubbles up to tryCatch
tryCatch(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)
#> Level 1
#> Level 2
```

You can prevent bubbling up to run the rest of the code in the block with `rlang::cnd_muffle()`
```{r}
# Muffles the default handler which prints the messages
withCallingHandlers(
  message = function(cnd) {
    cat("Level 2\n")
    cnd_muffle(cnd)
  },
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)
#> Level 1
#> Level 2

# Muffles level 2 handler and the default handler
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) {
      cat("Level 1\n")
      cnd_muffle(cnd)
    },
    message("Hello")
  )
)
#> Level 1
```

## Custom Conditions
Most function in R generate one of the built-in conditions, which contain only a message and a call. This can make error handling tricky, particularly if you want to detect a specific type of error

`rlang::abort()` allows you to create conditions that can contain additional metadata. The basic structure:
```{r}
abort(
  "error_not_found", # name of the type of error
  message = "Path `blah.csv` not found",  # message for the user
  path = "blah.csv" # custom metadata
)
#> Error: Path `blah.csv` not found
```

### signalling
Example:
```{r}
abort_bad_argument <- function(arg, must, not = NULL) {
  msg <- glue::glue("`{arg}` must {must}") # create a nice error message for the user
  if (!is.null(not)) {
    not <- typeof(not)
    msg <- glue::glue("{msg}; not {not}.")
  }
  
  abort("error_bad_argument", 
    message = msg,  # store metadata for the developer
    arg = arg, 
    must = must, 
    not = not
  )
}
```

## Applications
### failure value
A wrapper to return a default value if an error occurs using `tryCatch()`
```{r}
fail_with <- function(expr, value = NULL) {
  tryCatch(
    error = function(cnd) value,
    expr
  )
}

fail_with(log(10), NA_real_)
#> [1] 2.3
fail_with(log("x"), NA_real_)
#> [1] NA
```

### success and failure values
A wrapper to return a value if the code evaluates successfully and another if it fails. The basic structure would be:
```{r}
foo <- function(expr) {
  tryCatch(
    error = function(cnd) error_val,
    {
      expr
      success_val
    }
  )
}
```
